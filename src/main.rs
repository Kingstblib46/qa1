mod r1cs;

use ark_bls12_381::{Bls12_381, Fr};
use ark_ff::{PrimeField, BigInteger}; // BigInteger is used for val.into_bigint()
use ark_groth16::{prepare_verifying_key, Groth16};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError};
use ark_std::rand::{rngs::StdRng, SeedableRng};
use std::io::{self, ErrorKind};
use std::path::{Path, PathBuf};
use ark_snark::SNARK;

use ark_circom::WitnessCalculator;
use num_bigint::BigInt; // num_bigint::BigInt is used for calculated_witness_bigint and input parsing
use std::str::FromStr;

// For parsing JSON inputs
use serde_json::Value as JsonValue;
use std::collections::HashMap;

// Wasmer store for WitnessCalculator
use wasmer::Store;

struct CircuitFromR1CS {
    r1cs: r1cs::R1CS,
    witness_values: Vec<Fr>,
}

impl CircuitFromR1CS {
    fn new(r1cs_data: r1cs::R1CS, r1cs_file_path: &Path) -> io::Result<Self> {
        println!("Initializing CircuitFromR1CS with witness calculation...");

        let wasm_file_path = {
            let parent_dir = r1cs_file_path.parent().ok_or_else(|| {
                io::Error::new(ErrorKind::NotFound, "R1CS parent directory not found")
            })?;
            let circuit_name_stem = r1cs_file_path.file_stem().ok_or_else(|| {
                io::Error::new(ErrorKind::InvalidInput, "Could not extract R1CS file stem")
            })?;
            let circuit_name = circuit_name_stem.to_str().unwrap_or("circuit");
            parent_dir
                .join(format!("{}_js", circuit_name))
                .join(format!("{}.wasm", circuit_name))
        };

        println!("  Attempting to use WASM file: {}", wasm_file_path.display());

        if !wasm_file_path.exists() {
            let error_msg = format!(
                "WASM file not found at: {}. Please ensure it is generated by `circom circuit.circom --r1cs --wasm --sym`",
                wasm_file_path.display()
            );
            eprintln!("❌ {}", error_msg);
            return Err(io::Error::new(ErrorKind::NotFound, error_msg));
        }

        // Create a Wasmer store
        let mut store = Store::default();

        let mut witness_calculator = WitnessCalculator::new(&mut store, &wasm_file_path) // Pass store here
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Failed to load WASM: {:?}", e)))?;

        let inputs_json_str = r#"{"in": ["0", "1", "0", "1"]}"#;
        println!("  Using private inputs for witness calculation: {}", inputs_json_str);

        // Parse JSON string into HashMap<String, Vec<BigInt>>
        let parsed_inputs_map: HashMap<String, JsonValue> = serde_json::from_str(inputs_json_str)
            .map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse inputs JSON: {}", e)))?;
        
        let mut inputs_for_calculator: Vec<(String, Vec<BigInt>)> = Vec::new();
        for (key, json_val_array) in parsed_inputs_map {
            if let JsonValue::Array(string_array) = json_val_array {
                let bigint_vec: Result<Vec<BigInt>, _> = string_array.into_iter()
                    .map(|s_val| {
                        if let JsonValue::String(s) = s_val {
                            BigInt::from_str(&s).map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse BigInt string '{}': {}", s, e)))
                        } else {
                            Err(io::Error::new(ErrorKind::InvalidInput, "Input array element not a string"))
                        }
                    })
                    .collect();
                inputs_for_calculator.push((key, bigint_vec?));
            } else {
                return Err(io::Error::new(ErrorKind::InvalidInput, format!("JSON value for key '{}' is not an array", key)));
            }
        }
        
        println!("  Parsed inputs for calculator: {:?}", inputs_for_calculator);

        let calculated_witness_bigint: Vec<num_bigint::BigInt> = witness_calculator
            .calculate_witness(&mut store, inputs_for_calculator, false) // Use calculate_witness and pass store
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Witness calculation failed: {:?}", e)))?;

        println!("  Raw witness calculated ({} values):", calculated_witness_bigint.len());
        for (i, val) in calculated_witness_bigint.iter().enumerate().take(10) {
            println!("    raw_w[{}] = {}", i, val);
        }

        if calculated_witness_bigint.len() != r1cs_data.num_wires() as usize {
            let error_msg = format!(
                "Witness length mismatch: expected {}, got {}",
                r1cs_data.num_wires(),
                calculated_witness_bigint.len()
            );
            eprintln!("❌ {}", error_msg);
            return Err(io::Error::new(ErrorKind::InvalidData, error_msg));
        }

        let witness_values_fr: Vec<Fr> = calculated_witness_bigint
            .into_iter()
            .map(|bi| {
                Fr::from_str(&bi.to_string())
                    .unwrap_or_else(|e| panic!("Failed to convert BigInt {} to Fr: {:?}", bi, e))
            })
            .collect();

        println!("  Converted witness values (Fr):");
        for (i, val) in witness_values_fr.iter().enumerate().take(r1cs_data.num_wires() as usize) {
            println!("    w[{}] = {:?}", i, val.into_bigint()); // .into_bigint() uses ark_ff::BigInteger
        }

        Ok(Self {
            r1cs: r1cs_data,
            witness_values: witness_values_fr,
        })
    }

    fn get_public_inputs(&self) -> Vec<Fr> {
        let mut public_inputs = Vec::new();

        let num_pub_out = self.r1cs.num_public_outputs() as usize;
        let num_pub_in = self.r1cs.num_public_inputs() as usize;

        for i in 1..=(num_pub_out) {
            if i < self.witness_values.len() {
                public_inputs.push(self.witness_values[i]);
            } else {
                eprintln!("Warning: Accessing witness_values out of bounds for public output index {}", i);
            }
        }
        for i in (num_pub_out + 1)..=(num_pub_out + num_pub_in) {
            if i < self.witness_values.len() {
                public_inputs.push(self.witness_values[i]);
            } else {
                eprintln!("Warning: Accessing witness_values out of bounds for public input index {}", i);
            }
        }

        println!("  Extracted public inputs for verification ({} values):", public_inputs.len());
        for (i, pi) in public_inputs.iter().enumerate() {
            println!("    ark_pi[{}] = {:?}", i, pi.into_bigint());
        }
        public_inputs
    }
}

impl ConstraintSynthesizer<Fr> for CircuitFromR1CS {
    fn generate_constraints(
        self,
        cs: ConstraintSystemRef<Fr>,
    ) -> Result<(), SynthesisError> {
        println!("Generating constraints for R1CS circuit...");

        let num_total_wires = self.r1cs.num_wires() as usize;
        let num_public_circuit_outputs = self.r1cs.num_public_outputs() as usize;
        let num_public_circuit_inputs = self.r1cs.num_public_inputs() as usize;

        let num_ark_public_vars = 1 + num_public_circuit_outputs + num_public_circuit_inputs;

        println!(
            "  Allocating {} total wires for CS. Witness vector length: {}",
            num_total_wires, self.witness_values.len()
        );
        println!(
            "  Circuit public outputs: {}, Circuit public inputs: {}",
            num_public_circuit_outputs, num_public_circuit_inputs
        );
        println!("  Arkworks public variables to allocate: {}", num_ark_public_vars);

        let mut variables = Vec::with_capacity(num_total_wires);

        let one_val = self.witness_values.get(0).cloned().ok_or(SynthesisError::AssignmentMissing)?;
        if one_val != Fr::from(1u64) {
            eprintln!("Warning: Expected witness_values[0] to be Fr::one(), but got {:?}", one_val.into_bigint());
        }
        let var_one = cs.new_input_variable(|| Ok(one_val))?;
        variables.push(var_one);
        println!("    Allocated var_one (w[0]): {:?}", one_val.into_bigint());

        for i in 1..=num_public_circuit_outputs {
            let val = self.witness_values.get(i).cloned().ok_or(SynthesisError::AssignmentMissing)?;
            variables.push(cs.new_input_variable(|| Ok(val))?);
            println!("    Allocated public output (w[{}]) as input_var: {:?}", i, val.into_bigint());
        }

        for i in (num_public_circuit_outputs + 1)..=(num_public_circuit_outputs + num_public_circuit_inputs) {
            let val = self.witness_values.get(i).cloned().ok_or(SynthesisError::AssignmentMissing)?;
            variables.push(cs.new_input_variable(|| Ok(val))?);
            println!("    Allocated public input (w[{}]) as input_var: {:?}", i, val.into_bigint());
        }

        let private_vars_start_idx = num_ark_public_vars;
        for i in private_vars_start_idx..num_total_wires {
            let val = self.witness_values.get(i).cloned().ok_or(SynthesisError::AssignmentMissing)?;
            variables.push(cs.new_witness_variable(|| Ok(val))?);
            println!("    Allocated private (w[{}]) as witness_var: {:?}", i, val.into_bigint());
        }

        if variables.len() != num_total_wires {
            eprintln!("Error: Allocated {} variables in CS, but expected {} (num_total_wires)", variables.len(), num_total_wires);
            return Err(SynthesisError::UnconstrainedVariable);
        }

        println!("  Adding {} constraints to the circuit...", self.r1cs.constraints().len());
        for (idx, constraint) in self.r1cs.constraints().iter().enumerate() {
            let mut a_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.a_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: A-term wire_id {} out of bounds (vars len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                a_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut b_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.b_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: B-term wire_id {} out of bounds (vars len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                b_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut c_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.c_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: C-term wire_id {} out of bounds (vars len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                c_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            cs.enforce_constraint(a_lc.clone(), b_lc.clone(), c_lc.clone())?;

            if idx < 3 || idx == self.r1cs.constraints().len() - 1 {
                println!("    Enforced constraint #{}: ({:?}) * ({:?}) = {:?}", idx, a_lc, b_lc, c_lc);
            } else if idx == 3 && self.r1cs.constraints().len() > 4 {
                println!("    ... and {} more constraints", self.r1cs.constraints().len() - 4);
            }
        }

        println!("  Circuit constraint generation complete.");
        Ok(())
    }
}

#[tokio::main] // Add this attribute
async fn main() -> io::Result<()> { // Make main async
    let r1cs_file_path = PathBuf::from("/Users/hiranokaoru/localwork/work/circomlib-cff5ab6/Decoder@multiplexer.r1cs");
    println!("📂 Using R1CS file: {}", r1cs_file_path.display());

    let r1cs_data = r1cs::R1CS::read(&r1cs_file_path).map_err(|e| {
        eprintln!("❌ Failed to read R1CS file: {}", e);
        e
    })?;
    println!("✅ Successfully parsed R1CS file structure");
    r1cs_data.print_info();

    println!("\nCreating circuit from R1CS with WASM witness generation...");
    let circuit_for_setup = CircuitFromR1CS::new(r1cs_data, &r1cs_file_path)?;

    println!("\nRunning Groth16 setup...");
    let mut rng = StdRng::seed_from_u64(123456789);

    let params = Groth16::<Bls12_381>::generate_random_parameters_with_reduction(
        circuit_for_setup,
        &mut rng,
    )
    .map_err(|e| {
        eprintln!("❌ Failed to generate Groth16 parameters: {}", e);
        io::Error::new(ErrorKind::Other, format!("{}", e))
    })?;
    println!("✅ Successfully generated Groth16 parameters");

    println!("\nRe-creating circuit for proving...");
    let r1cs_data_for_proving = r1cs::R1CS::read(&r1cs_file_path)?;
    let circuit_for_proving = CircuitFromR1CS::new(r1cs_data_for_proving, &r1cs_file_path)?;

    let public_inputs = circuit_for_proving.get_public_inputs();
    println!("  Confirmed public inputs for proving: {} values.", public_inputs.len());

    println!("\nGenerating Groth16 proof...");
    let proof = Groth16::<Bls12_381>::prove(&params, circuit_for_proving, &mut rng)
        .map_err(|e| {
            eprintln!("❌ Failed to generate proof: {}", e);
            io::Error::new(ErrorKind::Other, format!("{}", e))
        })?;
    println!("✅ Successfully generated proof");

    println!("\nVerifying proof locally...");
    let pvk = prepare_verifying_key(&params.vk);

    match Groth16::<Bls12_381>::verify_with_processed_vk(&pvk, &public_inputs, &proof) { // Remove .await
        Ok(true) => println!("✅ Proof verified successfully!"),
        Ok(false) => {
            eprintln!("❌ Proof verification failed!");
            return Err(io::Error::new(ErrorKind::Other, "Proof verification failed"));
        }
        Err(e) => {
            eprintln!("❌ Error during verification: {}", e);
            return Err(io::Error::new(ErrorKind::Other, format!("Verification error: {}", e)));
        }
    }

    println!("\nR1CS processing complete!");
    Ok(())
}