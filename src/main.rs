mod r1cs;

use ark_bls12_381::{Bls12_381, Fr};
use ark_ff::{PrimeField, BigInteger}; // BigInteger is used for val.into_bigint()
use ark_groth16::{prepare_verifying_key, Groth16};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError, Variable};
use ark_std::rand::{rngs::StdRng, SeedableRng};
use std::io::{self, ErrorKind, Error as IoError};
use std::path::{Path, PathBuf};
use ark_snark::SNARK;

use ark_circom::WitnessCalculator;
use num_bigint::BigInt as NumBigInt; // Renamed to avoid confusion with ark_ff::BigInteger
use std::str::FromStr;

// For parsing JSON inputs
use serde_json::Value as JsonValue;
use std::collections::HashMap;

// Wasmer store for WitnessCalculator
use wasmer::Store;

use std::env;

struct CircuitFromR1CS {
    r1cs: r1cs::R1CS,
    witness_values: Vec<Fr>,
}

impl CircuitFromR1CS {
    // å¢åŠ ä¸€ä¸ªå¯é€‰ wasm_path å‚æ•°
    fn new(
        r1cs_data: r1cs::R1CS,
        r1cs_file_path: &Path,
        wasm_file_path_opt: Option<&Path>,
    ) -> io::Result<Self> {
        println!("Initializing CircuitFromR1CS with witness calculationâ€¦");

        // å¦‚æœå‘½ä»¤è¡Œç»™äº† wasm è·¯å¾„ï¼Œå°±ç”¨å®ƒï¼Œå¦åˆ™æŒ‰åŸé€»è¾‘è‡ªåŠ¨æ¨æ–­
        let wasm_file_path = if let Some(p) = wasm_file_path_opt {
            p.to_path_buf()
        } else {
            let parent_dir = r1cs_file_path.parent().ok_or_else(|| {
                io::Error::new(ErrorKind::NotFound, "R1CS parent directory not found")
            })?;
            let stem = r1cs_file_path
                .file_stem()
                .and_then(|s| s.to_str())
                .ok_or_else(|| io::Error::new(ErrorKind::InvalidInput, "Bad R1CS file stem"))?;
            parent_dir.join(format!("{}_js/{}.wasm", stem, stem))
        };

        println!("  Using WASM file: {}", wasm_file_path.display());

        if !wasm_file_path.exists() {
            let error_msg = format!(
                "WASM file not found at: {}. Please ensure it is generated by `circom circuit.circom --r1cs --wasm --sym`",
                wasm_file_path.display()
            );
            eprintln!("âŒ {}", error_msg);
            return Err(io::Error::new(ErrorKind::NotFound, error_msg));
        }

        let mut store = Store::default();
        let mut witness_calculator = WitnessCalculator::new(&mut store, &wasm_file_path)
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Failed to load WASM: {:?}", e)))?;

        let inputs_json_str = r#"{"sel": ["0"]}"#; 
        println!("  Using private inputs for witness calculation: {}", inputs_json_str);

        let parsed_inputs_map: HashMap<String, JsonValue> = serde_json::from_str(inputs_json_str)
            .map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse inputs JSON: {}", e)))?;
        
        let mut inputs_for_calculator: Vec<(String, Vec<NumBigInt>)> = Vec::new();
        for (key, json_val_or_array) in parsed_inputs_map {
            let mut current_signal_values = Vec::new();
            if let JsonValue::Array(string_array) = json_val_or_array {
                for s_val in string_array {
                    if let JsonValue::String(s) = s_val {
                        current_signal_values.push(NumBigInt::from_str(&s).map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse NumBigInt string '{}': {}", s, e)))?);
                    } else {
                        return Err(io::Error::new(ErrorKind::InvalidInput, "Input array element not a string"));
                    }
                }
            } else if let JsonValue::String(s_val) = json_val_or_array {
                 current_signal_values.push(NumBigInt::from_str(&s_val).map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse NumBigInt string '{}': {}", s_val, e)))?);
            } else {
                return Err(io::Error::new(ErrorKind::InvalidInput, format!("JSON value for key '{}' is not a string or an array of strings", key)));
            }
            inputs_for_calculator.push((key, current_signal_values));
        }
        
        println!("  Parsed inputs for calculator: {:?}", inputs_for_calculator);

        let calculated_witness_bigint: Vec<NumBigInt> = witness_calculator
            .calculate_witness(&mut store, inputs_for_calculator, true) 
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Witness calculation failed (sanity check enabled): {:?}", e)))?;

        println!("  Raw witness calculated ({} values):", calculated_witness_bigint.len());
        for (i, val) in calculated_witness_bigint.iter().enumerate().take(10.min(calculated_witness_bigint.len())) { // Print up to 10 or length
            println!("    raw_w[{}] = {}", i, val);
        }

        if calculated_witness_bigint.len() != r1cs_data.num_wires() as usize {
            let error_msg = format!(
                "Witness length mismatch: expected {}, got {}",
                r1cs_data.num_wires(),
                calculated_witness_bigint.len()
            );
            eprintln!("âŒ {}", error_msg);
            return Err(io::Error::new(ErrorKind::InvalidData, error_msg));
        }

        let witness_values_fr: Vec<Fr> = calculated_witness_bigint
            .into_iter()
            .map(|bi| {
                Fr::from_str(&bi.to_string())
                    .unwrap_or_else(|e| panic!("Failed to convert NumBigInt {} to Fr: {:?}", bi, e))
            })
            .collect();

        println!("  Converted witness values (Fr) ({} values):", witness_values_fr.len());
        for (i, val) in witness_values_fr.iter().enumerate() { // Print all Fr witness values
            println!("    witness_values_fr[{}] (w[{}]) = {:?}", i, i, val.into_bigint());
        }

        Ok(Self {
            r1cs: r1cs_data,
            witness_values: witness_values_fr,
        })
    }

    fn get_public_inputs(&self) -> Vec<Fr> {
        println!("  Extracting public inputs for verification from witness_values:");
        let mut public_inputs = Vec::new();

        let num_pub_out = self.r1cs.num_public_outputs() as usize;
        // Based on R1CS for Decoder@multiplexer, num_pub_in is 0.
        // let num_pub_in_from_r1cs = self.r1cs.num_public_inputs() as usize; 

        // Circom witness structure: w[0] is 1, w[1]...w[num_pub_out] are public outputs.
        // Then w[num_pub_out+1]...w[num_pub_out+num_pub_in_from_r1cs] would be public inputs from R1CS.
        // Arkworks Groth16 verification expects public inputs in the order: [public outputs, public inputs from R1CS]
        
        println!("    Number of public outputs from R1CS: {}", num_pub_out);
        for i in 1..=num_pub_out { // Public outputs start at witness_values[1]
            if i < self.witness_values.len() {
                public_inputs.push(self.witness_values[i]);
                println!("      Added witness_values[{}] ({:?}) as public output for verification.", i, self.witness_values[i].into_bigint());
            } else {
                eprintln!("      Warning: Accessing witness_values out of bounds for public output index {}", i);
            }
        }
        
        // This loop will not run for Decoder@multiplexer as num_public_inputs is 0
        // let r1cs_pub_inputs_start_idx = 1 + num_pub_out;
        // for i in 0..num_pub_in_from_r1cs {
        //     let witness_idx = r1cs_pub_inputs_start_idx + i;
        //     if witness_idx < self.witness_values.len() {
        //         public_inputs.push(self.witness_values[witness_idx]);
        //         println!("      Added witness_values[{}] ({:?}) as R1CS public input for verification.", witness_idx, self.witness_values[witness_idx].into_bigint());
        //     } else {
        //          eprintln!("      Warning: Accessing witness_values out of bounds for R1CS public input index {}", witness_idx);
        //     }
        // }

        println!("  Final extracted public inputs for verification ({} values):", public_inputs.len());
        for (i, pi) in public_inputs.iter().enumerate() {
            println!("    ark_pi_for_verification[{}] = {:?}", i, pi.into_bigint());
        }
        public_inputs
    }
}

impl ConstraintSynthesizer<Fr> for CircuitFromR1CS {
    fn generate_constraints(
        self,
        cs: ConstraintSystemRef<Fr>,
    ) -> Result<(), SynthesisError> {
        println!("Generating constraints for R1CS circuit...");
        println!("  Initial CS state: num_instance_vars={}, num_witness_vars={}, num_constraints={}",
                 cs.num_instance_variables(), cs.num_witness_variables(), cs.num_constraints());

        let num_total_wires = self.r1cs.num_wires() as usize; // e.g., 5 for Decoder@multiplexer
        let num_public_circuit_outputs = self.r1cs.num_public_outputs() as usize; // e.g., 3
        let num_public_circuit_inputs = self.r1cs.num_public_inputs() as usize; // e.g., 0

        // This is the count of variables that will be cs.new_input_variable()
        // This counts the public outputs and R1CS public inputs.
        // The 'one' variable is already provided by cs.one() / Instance(0).
        let num_additional_ark_instance_vars_to_allocate = num_public_circuit_outputs + num_public_circuit_inputs;
        let expected_total_ark_instance_vars = 1 + num_additional_ark_instance_vars_to_allocate;


        println!(
            "  R1CS wires: {}, Witness vector length: {}",
            num_total_wires, self.witness_values.len()
        );
        println!(
            "  R1CS public outputs: {}, R1CS public inputs: {}",
            num_public_circuit_outputs, num_public_circuit_inputs
        );
        println!("  Expected total Arkworks Instance Variables (1 (for cs.one()) + outs + ins): {}", expected_total_ark_instance_vars);

        let mut variables = Vec::with_capacity(num_total_wires);

        // Wire 0: Constant One. Use Variable::One which represents the existing Instance(0).
        println!("  Allocating CS variables from witness_values (length {}):", self.witness_values.len());
        let one_val_from_witness = self.witness_values.get(0).cloned().ok_or_else(|| {
            eprintln!("Error: witness_values[0] (constant one) is missing.");
            SynthesisError::AssignmentMissing
        })?;
        if one_val_from_witness != Fr::from(1u64) {
            eprintln!("Warning: Expected witness_values[0] to be Fr::one(), but got {:?}", one_val_from_witness.into_bigint());
        }
        
        let var_one_cs = Variable::One; // Corrected: Use Variable::One
        variables.push(var_one_cs);
        // Note: cs.num_instance_variables() will still be 1 here, as Variable::One refers to the *existing* Instance(0).
        // The count increases when cs.new_input_variable() is called.
        println!("    w[0] (val:{:?}) -> mapped to CS ONE Var: {:?} (initial cs.num_instance_vars: {})", one_val_from_witness.into_bigint(), var_one_cs, cs.num_instance_variables());


        // Public outputs of the circuit (Instance variables in Arkworks, starting from Instance(1))
        for i in 1..=num_public_circuit_outputs {
            let val = self.witness_values.get(i).cloned().ok_or_else(|| {
                 eprintln!("Error: witness_values[{}] (public output) is missing.", i);
                SynthesisError::AssignmentMissing
            })?;
            let var = cs.new_input_variable(|| Ok(val))?; // These will be Instance(1), Instance(2), ...
            variables.push(var);
            println!("    w[{}] (val:{:?}) -> CS Var: {:?} (current cs.num_instance_vars: {})", i, val.into_bigint(), var, cs.num_instance_variables());
        }

        // Public inputs of the circuit (Instance variables in Arkworks)
        // For Decoder@multiplexer, num_public_circuit_inputs is 0, so this loop won't run.
        let r1cs_pub_ins_start_idx_in_witness = 1 + num_public_circuit_outputs;
        for i in 0..num_public_circuit_inputs {
            let witness_idx = r1cs_pub_ins_start_idx_in_witness + i;
            let val = self.witness_values.get(witness_idx).cloned().ok_or_else(|| {
                eprintln!("Error: witness_values[{}] (R1CS public input) is missing.", witness_idx);
                SynthesisError::AssignmentMissing
            })?;
            let var = cs.new_input_variable(|| Ok(val))?;
            variables.push(var);
            println!("    w[{}] (val:{:?}) -> CS Var: {:?} (current cs.num_instance_vars: {})", witness_idx, val.into_bigint(), var, cs.num_instance_variables());
        }
        
        // Private inputs of the circuit (Witness variables in Arkworks)
        let private_vars_start_idx_in_witness = 1 + num_public_circuit_outputs + num_public_circuit_inputs;
        for i in private_vars_start_idx_in_witness..num_total_wires {
            // i here is the witness_values index for private variables
            let val = self.witness_values.get(i).cloned().ok_or_else(|| {
                 eprintln!("Error: witness_values[{}] (private variable) is missing.", i);
                SynthesisError::AssignmentMissing
            })?;
            let var = cs.new_witness_variable(|| Ok(val))?;
            variables.push(var);
            println!("    w[{}] (val:{:?}) -> CS Var: {:?} (current cs.num_witness_vars: {})", i, val.into_bigint(), var, cs.num_witness_variables());
        }
        
        println!("  After allocating all variables from witness_values:");
        println!("    Total variables pushed to `variables` vector: {}", variables.len());
        println!("    CS state: num_instance_vars={}, num_witness_vars={}, num_constraints={}",
                 cs.num_instance_variables(), cs.num_witness_variables(), cs.num_constraints());

        if variables.len() != num_total_wires {
            eprintln!("Error: Allocated {} CS variables, but R1CS specifies {} total wires.", variables.len(), num_total_wires);
            return Err(SynthesisError::UnconstrainedVariable); 
        }
        // Check against expected_total_ark_instance_vars
        if cs.num_instance_variables() != expected_total_ark_instance_vars {
             eprintln!("Error: CS has {} instance variables, but expected {}.", cs.num_instance_variables(), expected_total_ark_instance_vars);
            return Err(SynthesisError::UnconstrainedVariable);
        }
        // The number of witness variables allocated by cs.new_witness_variable()
        let expected_ark_witness_vars = num_total_wires - expected_total_ark_instance_vars;
        if cs.num_witness_variables() != expected_ark_witness_vars {
             eprintln!("Error: CS has {} witness variables, but expected {}.", cs.num_witness_variables(), expected_ark_witness_vars);
            return Err(SynthesisError::UnconstrainedVariable);
        }


        println!("  Adding {} R1CS constraints to the circuit...", self.r1cs.constraints().len());
        for (idx, constraint) in self.r1cs.constraints().iter().enumerate() {
            let mut a_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            // println!("    Constraint #{}: A terms:", idx);
            for term in &constraint.a_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: A-term wire_id {} (0-indexed) out of bounds for `variables` vector (len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                // println!("      Adding A-term: coef={:?}, var_from_w[{}]={:?}", term.coefficient, term.wire_id, variables[term.wire_id as usize]);
                a_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut b_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            // println!("    Constraint #{}: B terms:", idx);
            for term in &constraint.b_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: B-term wire_id {} (0-indexed) out of bounds for `variables` vector (len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                // println!("      Adding B-term: coef={:?}, var_from_w[{}]={:?}", term.coefficient, term.wire_id, variables[term.wire_id as usize]);
                b_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut c_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            // println!("    Constraint #{}: C terms:", idx);
            for term in &constraint.c_terms {
                if term.wire_id as usize >= variables.len() {
                    eprintln!("Error: C-term wire_id {} (0-indexed) out of bounds for `variables` vector (len {}) for constraint {}", term.wire_id, variables.len(), idx);
                    return Err(SynthesisError::AssignmentMissing);
                }
                // println!("      Adding C-term: coef={:?}, var_from_w[{}]={:?}", term.coefficient, term.wire_id, variables[term.wire_id as usize]);
                c_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            cs.enforce_constraint(a_lc.clone(), b_lc.clone(), c_lc.clone())?;

            if idx < 3 || idx == self.r1cs.constraints().len() - 1 { // Print first 3 and last
                println!("    Enforced R1CS constraint #{}: ({:?}) * ({:?}) = {:?}", idx, a_lc, b_lc, c_lc);
            } else if idx == 3 && self.r1cs.constraints().len() > 4 {
                println!("    ... (constraints {} to {} not shown in detail) ...", idx, self.r1cs.constraints().len() - 2);
            }
        }

        println!("  Circuit constraint generation complete.");
        println!("  Final CS state: num_instance_vars={}, num_witness_vars={}, num_constraints={}",
                 cs.num_instance_variables(), cs.num_witness_variables(), cs.num_constraints());
        Ok(())
    }
}

#[allow(unused_imports)] // Allow BigInteger for now
#[tokio::main]
async fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 || args.len() > 3 {
        eprintln!("ç”¨æ³•: {} <circuit.r1cs> [circuit.wasm]", args[0]);
        std::process::exit(1);
    }
    // å¿…å¡« R1CS è·¯å¾„
    let r1cs_file_path = PathBuf::from(&args[1]);
    // å¯é€‰ WASM è·¯å¾„
    let wasm_opt: Option<&Path> = args.get(2).map(|s| Path::new(s));

    println!("ğŸ“‚ Using R1CS file: {}", r1cs_file_path.display());

    let r1cs_data = r1cs::R1CS::read(&r1cs_file_path)
        .map_err(|e| { eprintln!("âŒ Failed to read R1CS file: {}", e); e })?;
    println!("âœ… Parsed R1CS, constraints = {}", r1cs_data.num_constraints());

    println!("\nCreating circuit from R1CSâ€¦");
    let circuit_for_setup = CircuitFromR1CS::new(r1cs_data, &r1cs_file_path, wasm_opt)?;

    println!("\nRunning Groth16 setup...");
    let mut rng = StdRng::seed_from_u64(123456789);

    let params = Groth16::<Bls12_381>::generate_random_parameters_with_reduction(
        circuit_for_setup,
        &mut rng,
    )
    .map_err(|e| {
        eprintln!("âŒ Failed to generate Groth16 parameters: {}", e);
        io::Error::new(ErrorKind::Other, format!("{}", e))
    })?;
    println!("âœ… Successfully generated Groth16 parameters");

    println!("\nRe-creating circuit for proving...");
    // Need to re-read r1cs_data as it was moved into circuit_for_setup
    let r1cs_data2 = r1cs::R1CS::read(&r1cs_file_path)?;
    let circuit_for_proving = CircuitFromR1CS::new(r1cs_data2, &r1cs_file_path, wasm_opt)?;

    let public_inputs = circuit_for_proving.get_public_inputs();
    println!("  Confirmed public inputs for proving ({} values).", public_inputs.len());

    println!("\nGenerating Groth16 proof...");
    let proof = Groth16::<Bls12_381>::prove(&params, circuit_for_proving, &mut rng)
        .map_err(|e| {
            eprintln!("âŒ Failed to generate proof: {}", e);
            io::Error::new(ErrorKind::Other, format!("{}", e))
        })?;
    println!("âœ… Successfully generated proof");

    println!("\nVerifying proof locally...");
    let pvk = prepare_verifying_key(&params.vk);

    match Groth16::<Bls12_381>::verify_with_processed_vk(&pvk, &public_inputs, &proof) {
        Ok(true) => println!("âœ… Proof verified successfully!"),
        Ok(false) => {
            eprintln!("âŒ Proof verification failed!");
            return Err(io::Error::new(ErrorKind::Other, "Proof verification failed"));
        }
        Err(e) => {
            eprintln!("âŒ Error during verification: {}", e);
            return Err(io::Error::new(ErrorKind::Other, format!("Verification error: {}", e)));
        }
    }

    println!("\nR1CS processing complete!");

    // === 4. åºåˆ—åŒ–ä¸º Dogecoin OP_CHECKZKP è„šæœ¬æ¨é€æ ¼å¼ ===
    {
        use ark_ec::AffineRepr;
        use ark_serialize::{CanonicalSerialize, Compress};
        use std::fs::File;
        use std::io::Write;

        // 4.1 Proof åºåˆ—åŒ–ï¼ˆÏ€_A, Ï€_B, Ï€_C å…± 8 é¡¹ï¼‰ï¼š48/96/48 bytes
        let mut proof_bytes: Vec<Vec<u8>> = Vec::with_capacity(8);
        // Ï€_A (G1)
        proof_bytes.push({
            let mut v = Vec::new();
            proof.a.x().unwrap().serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        });
        proof_bytes.push({
            let mut v = Vec::new();
            proof.a.y().unwrap().serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        });
        // Ï€_B (G2: Fq2 æ‹† c0,c1)
        {
            let mut v = Vec::new();
            proof.b.x().unwrap().c0.serialize_with_mode(&mut v, Compress::Yes).unwrap();
            proof.b.x().unwrap().c1.serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        }.chunks(48).for_each(|c| proof_bytes.push(c.to_vec()));
        {
            let mut v = Vec::new();
            proof.b.y().unwrap().c0.serialize_with_mode(&mut v, Compress::Yes).unwrap();
            proof.b.y().unwrap().c1.serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        }.chunks(48).for_each(|c| proof_bytes.push(c.to_vec()));
        // Ï€_C (G1)
        proof_bytes.push({
            let mut v = Vec::new();
            proof.c.x().unwrap().serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        });
        proof_bytes.push({
            let mut v = Vec::new();
            proof.c.y().unwrap().serialize_with_mode(&mut v, Compress::Yes).unwrap();
            v
        });
        assert_eq!(proof_bytes.len(), 8, "proof_bytes.len() å¿…é¡»æ˜¯ 8");

        // 4.2 Public inputs åºåˆ—åŒ–ï¼ˆæ¯ä¸ª Fr 32 å­—èŠ‚ LE å‰å¡«é›¶ï¼‰
        fn fr_to_32le(f: &Fr) -> Vec<u8> {
            let mut b = f.into_bigint().to_bytes_le();
            let mut z = vec![0u8; 32 - b.len()];
            z.append(&mut b);
            z
        }
        let pubi_bytes = public_inputs.iter().map(fr_to_32le).collect::<Vec<_>>();
        assert_eq!(
            pubi_bytes.len(),
            public_inputs.len(),
            "Expected {} public inputs, got {}",
            public_inputs.len(),
            pubi_bytes.len()
        );

        // 4.3 VK åºåˆ—åŒ–ï¼šalpha_g1(48) + beta_g2(96) + gamma_g2(96) + delta_g2(96) + gamma_abc_g1*(n_pub+1)*48
        let mut vk_bytes = Vec::new();
        params.vk.alpha_g1
            .serialize_compressed(&mut vk_bytes)
            .map_err(|e| IoError::new(ErrorKind::Other, format!("alpha_g1 serialization failed: {}", e)))?;
        params.vk.beta_g2
            .serialize_compressed(&mut vk_bytes)
            .map_err(|e| IoError::new(ErrorKind::Other, format!("beta_g2 serialization failed: {}", e)))?;
        params.vk.gamma_g2
            .serialize_compressed(&mut vk_bytes)
            .map_err(|e| IoError::new(ErrorKind::Other, format!("gamma_g2 serialization failed: {}", e)))?;
        params.vk.delta_g2
            .serialize_compressed(&mut vk_bytes)
            .map_err(|e| IoError::new(ErrorKind::Other, format!("delta_g2 serialization failed: {}", e)))?;
        for (i, g1) in params.vk.gamma_abc_g1.iter().enumerate() {
            g1.serialize_compressed(&mut vk_bytes)
                .map_err(|e| IoError::new(
                    ErrorKind::Other,
                    format!("gamma_abc_g1[{}] serialization failed: {}", i, e),
                ))?;
        }

        // åˆ† chunk ä¸º 80 å­—èŠ‚ä¸€æ®µ
        let vk_chunks = vk_bytes.chunks(80).map(|c| c.to_vec()).collect::<Vec<_>>();
        assert_eq!(vk_chunks.len(),  (vk_bytes.len() + 79) / 80);

        // 4.4 æŒ‰ OP_CHECKZKP Mode=0 é¡ºåºç»„è£…ï¼Œæœ€ç»ˆæ ˆé¡¹åˆ—è¡¨
        //   [proofâ€¦(8)][pubiâ€¦][vk_chunksâ€¦][mode=0]
        let mut stack: Vec<Vec<u8>> = Vec::new();
        // proof ä»æœ«å°¾å¼€å§‹æ¨
        for chunk in proof_bytes.into_iter().rev() { stack.push(chunk); }
        // public inputs
        for chunk in pubi_bytes.into_iter().rev() { stack.push(chunk); }
        // vk chunks
        for chunk in vk_chunks.into_iter().rev() { stack.push(chunk); }
        // æœ€åæ¨ mode=0
        stack.push(vec![0u8]);

        // 4.5 Hex ç¼–ç å¹¶è¾“å‡ºåˆ°ä¸¥æ ¼å‘½åçš„æ–‡ä»¶
        let txt_path = "/Users/hiranokaoru/localwork/work/qa1/zkp_stack_dip69.txt";
        let mut f = File::create(txt_path)?;
        for (i, item) in stack.iter().enumerate() {
            writeln!(f, "{}:{}", i, hex::encode(item))?;
        }
        println!("âœ… å·²ç”Ÿæˆ Dogecoin è„šæœ¬æ¨é€æ•°æ®ï¼š{}", txt_path);

        // åŒæ—¶å†™å…¥ä¸¥æ ¼å‘½åçš„ JSON
        let json_path = "/Users/hiranokaoru/localwork/work/qa1/zkp_stack_dip69.json";
        let mut jf = File::create(json_path)?;
        let hex_list: Vec<String> = stack.iter()
            .map(|item| hex::encode(item))
            .collect();
        serde_json::to_writer_pretty(&mut jf, &hex_list)
            .map_err(|e| IoError::new(ErrorKind::Other, format!("å†™å…¥ JSON å¤±è´¥: {}", e)))?;
        println!("âœ… å·²ç”Ÿæˆ JSON è„šæœ¬æ¨é€æ•°æ®ï¼š{}", json_path);

    }

    Ok(())
}